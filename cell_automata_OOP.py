"""
Created on Thu Mar 12 17:51:14 2020

@author: Alessio Giuseppe Ferraioli

CELL AUTOMATON SIMULATION
as defined in   https://mathworld.wolfram.com/Rule30.html

The evolution of a cellular automaton is a simple binary rule that determines the state of a cell 
in the next generation based on the state of its immediate neighbors.

Rule 30 is a set of rules determined by the binary number 30. In this simulation,
the evolution is generalized to "Rule N", where N can be any positive integer up to 255.


The evolution of the cellular automaton can be represented as a sequence of binary numbers,
where each number represents the state of a cell in a given generation. 


OOP version: this is the an alternative version of the script that uses object-oriented programming principles.

"""

import time

class CellularAutomaton:
    def __init__(self, size, rule):
        self.size = size
        self.rule = rule
        self.state = self.reset_state(size)
        self.states_seq = [self.state] # save the sequence of states 

    def reset_state(self, size):
    #function that generates the initial state 000010000 with length equal to size+2
    #the 0 is placed at center if size is odd; if size is even it is placed on the right of the center
    #it may be generalized to generate different states, maybe random ones

        state = '0'           # initialize the states as a string of a single 0
        for i in range(size+1):           
            if i==(size//2):
                state=state+'1'      # appends a 1 (alive) if we are at the center 
            else:
                state=state+'0'     # appends a 0 (dead) for any other i
        
        return state


    def evolve(self, old_state):
        '''takes in input a state and a numeric rule; returns the evolved state for the next step. 
        the rules of the evolution are given by Rule30 by Wolfram, available at:
        https://mathworld.wolfram.com/Rule30.html'''
    
        rule_bin=bin(self.rule)      # converts the number in a binary string
        
        winning=[]          # initialize the list of "winning numbers"
        
        for i in range(len(rule_bin)):
            if rule_bin[i]=='1':
                winning.append(len(rule_bin)-i-1)           # append to the winning numbers the positions of the 1s in the binary rule
                
        # initialize the new state as all 0s
        new_state='0'
        for i in range(len(old_state)-1):
            new_state=new_state+'0'
        
        # i use the convention that the boundaries are always dead because it's the simplest condition to implementate (I simply do not check for the boundaries and left them in the dead state)    
        for i in range(len(old_state)-2):        # l'indice i mi fa avanzare lungo il mio stato considerando 3 caselle alla volta
            casella_bin=int(old_state[i:i+3], base=2)      # interpreto la casella come un numero binario e lo salvo in casella_bin
            
            for j in range(len(winning)):                       # l'indice j mi fa confrontare la casella [i:i+2] con ogni j-esimo winning parameter          
                if(casella_bin==winning[j]):        # confronto il valore numerico della casella col j-esimo elemento di winning
                    new_state=new_state[:i+1]+'1'+new_state[i+2:]
            
        return new_state

    def print_state(self, alive_symbol='*', dead_symbol='.'):
        for i in range(len(self.states_seq)):
            print(self.format_print(self.states_seq[i], 'o','.'))
            time.sleep(0.5)

    def simulation(self, n_iterations=10):
        '''main function: it is the actual simulation.
        it takes in input the number of iterations on which the simulation is ran.
        from an initial state generated by generate_state produces a new evolved state by using evolve and iterate the procuder size times
        returns the sequence of all the size states in a list states_seq
        
        size: the size of the cellular automaton
        rule: the numeric rule for the evolution
        iterations: the number of steps for which the simulation is run
        '''
        
        initial_state = self.state  # take the actual state as the initial state 
        states_seq = [initial_state]      # initialize the sequence of states with the first one   
        for i in range(n_iterations):
            old_state = states_seq[-1]      # save the latest state in a temporary variable old_state
            new_state = self.evolve(old_state)   # create a new state by evolve function on the old_state and save it in the variable new_state 
            states_seq.append(new_state)    # append the new state in the list states.seq
        
        self.states_seq = states_seq # save the sequence of states 


    def start(self, n_iterations=10):
        '''starts the simulation with the given number of iterations'''
        self.simulation(n_iterations)
        self.print_state()


    ######################################################## 
    #functions to test the code

    def test_generation_valid_state(self):
        'tests that in the state generated by generate_state the only characters are . (dead) and 0 (alive)'
        state = generate_state()
        assert set(state) == {'.', '0'}
        
    def test_generation_single_alive(self):
        'tests that there is only one alive cell in the generated state'
        state = generate_state()
        num_of_0 = sum(1 for i in state if i=='0')
        assert num_of_0 == 1
        
    ###################################
    # functions for displaying
    def format_print(self, state, alive_symbol='*', dead_symbol='.'):
        ''' functoin to print the state in a more readable format,
        substituing the 0s with '.' and the 1s with '*' '''
        return ''.join(alive_symbol if i=='1' else dead_symbol for i in state)



# start the cell automaton
size = int(input("Size: "))
rule = int(input("Rule: "))
iterations = int(input("Iterations: "))



automaton = CellularAutomaton(size, rule)

print("\n--------------------------------------")
print("CELLULAR AUTOMATON SIMULATION")
print("--------------------------------------")
print(f"Rule {rule}\n")
# start the simulation
automaton.start(iterations)



